<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Potterhe&#39;s Site  | Jwt Notes</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.60.1" />
    
    
      <META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">
    

    
    
      <link href="/dist/css/app.1cb140d8ba31d5b2f1114537dd04802a.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="Jwt Notes" />
<meta property="og:description" content="JSON Web Token (JWT) JSON Web Key (JWK) jwt.io 一篇官方文档翻译，这篇文章里有一些标注为“个人补充”的内容，很有实践意义。  缓解技术依赖于对传递给后端的所有数据的正确验证。特别是，必须始终清理从客户端收到的任何数据。 如果使用cookie，则可以通过设置HttpOnly标志2来防止它们被JavaScript访问。 HttpOnly标志虽然有用，但不能保护cookie免遭CSRF攻击。
任何方法都有其优缺点，并且客户端会话也不例外3。 某些应用程序可能需要大量的会话。 为每个请求（或一组请求）来回发送此状态可以轻松克服后端减少聊天的好处。 后端的客户端数据和数据库查找之间必须保持一定的平衡。 这取决于您的应用程序的数据模型。 某些应用程序无法很好地映射到客户端会话。 其他可能完全取决于客户端数据。 这件事的最终决定权是你自己决定！ 运行基准测试，研究保留某些状态客户端的好处。 JWT太大了吗？ 这对带宽有影响吗？ 这样增加的带宽是否会取代后端减少的延迟？ 小请求可以汇总为单个大请求吗？ 这些请求是否仍然需要大型数据库查找？ 回答这些问题将帮助您确定正确的方法。
联合身份7系统允许不同（可能不相关）的各方与其他方共享身份验证和授权服务。 换句话说，用户的身份是集中的。 联合身份管理有多种解决方案：SAML8和OpenID Connect9是最常见的两种。 某些公司提供专门的产品，以集中身份验证和授权。 这些可以实现上述标准之一，也可以使用完全不同的标准。 其中一些公司为此目的使用JWT。 JWT用于集中式身份验证和授权的方法因公司而异，但是授权过程的基本流程是：
访问和刷新令牌是两种类型的令牌，在分析不同的联合身份解决方案时，您会经常看到它们。我们将简要解释它们是什么以及它们如何在身份验证和授权的上下文中提供帮助。 这两个概念通常在OAuth2规范的上下文中实现10。 OAuth2规范定义了通过将访问权限与所有权分开来提供对资源的访问所需的一系列步骤（换句话说，它允许具有不同访问级别的多个方访问同一资源）。这些步骤的几个部分由实现定义。也就是说，竞争的OAuth2实现可能无法互操作。例如，未指定令牌的实际二进制格式。它们的目的和功能是。 访问令牌是使拥有访问权限的人员可以访问受保护资源的令牌。这些令牌通常是短暂的，并且可能在其中嵌入了失效日期。它们还可以携带附加信息或与之关联（例如，访问令牌可以携带允许发出请求的IP地址）。此附加数据是实现定义的。 另一方面，刷新令牌允许客户端请求新的访问令牌。例如，在访问令牌到期后，客户端可以向授权服务器执行对新访问令牌的请求。为了满足此请求，需要刷新令牌。与访问令牌相反，刷新令牌通常是长期存在的。
访问令牌和刷新令牌之间分离的关键方面在于使访问令牌易于验证的可能性。带有签名（例如，签名的JWT）的访问令牌可以由资源服务器自行验证。为此，无需联系授权服务器。 另一方面，刷新令牌需要访问授权服务器。通过将验证与对授权服务器的查询分开，可以实现更好的延迟和更简单的访问模式。通过使访问令牌的寿命尽可能短，并将其他检查（例如客户端检查）嵌入到令牌中，可以实现令牌泄漏时的适当安全性。 刷新令牌的寿命很长，必须加以保护，以防泄漏。如果发生泄漏，则可能需要在服务器中将其列入黑名单（短暂的访问令牌会强制最终使用刷新令牌，从而在资源被列入黑名单且所有访问令牌都已过期后保护资源）。 注意：OAuth2中引入了访问令牌和刷新令牌的概念。 OAuth 1.0和1.0a使用单词令牌的方式有所不同。
尽管OAuth2没有提及其令牌的格式，但JWT可以很好地满足其要求。 签名的JWT具有良好的访问令牌，因为它们可以对所有必需的数据进行编码，以区分对资源的访问级别，可以带有到期日期，并进行签名以避免对授权服务器进行验证查询。 几个联合身份提供者以JWT格式发布访问令牌。 JWT也可以用于刷新令牌。 但是，没有太多理由将它们用于此目的。 由于刷新令牌需要访问授权服务器，因此在大多数情况下，一个简单的UUID就足够了，因为不需要令牌来承载有效负载（尽管可以对其进行签名）。
JSON Web Tokens in Detail
如第1章所述，所有JWT都由三个不同的元素构成：标头，有效负载和签名/加密数据。 前两个元素是具有特定结构的JSON对象。 第三个依赖于用于签名或加密的算法，如果是未加密的JWT，则将其省略。 JWT可以以称为JWS / JWE紧凑序列化的紧凑表示形式进行编码。 JWT使用一种对URL安全的Base64编码变体。 此编码基本上分别用“ &#43;”和“ /”字符代替“-”和“ _”字符。 填充也将被删除。 此变体称为base64url3。 请注意，本文档中对Base64编码的所有引用均指代此变体。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://potterhe.github.io/posts/jwt-handbook-notes/" />
<meta property="article:published_time" content="2020-03-29T17:06:48+08:00" />
<meta property="article:modified_time" content="2020-03-29T17:06:48+08:00" />
<meta itemprop="name" content="Jwt Notes">
<meta itemprop="description" content="JSON Web Token (JWT) JSON Web Key (JWK) jwt.io 一篇官方文档翻译，这篇文章里有一些标注为“个人补充”的内容，很有实践意义。  缓解技术依赖于对传递给后端的所有数据的正确验证。特别是，必须始终清理从客户端收到的任何数据。 如果使用cookie，则可以通过设置HttpOnly标志2来防止它们被JavaScript访问。 HttpOnly标志虽然有用，但不能保护cookie免遭CSRF攻击。
任何方法都有其优缺点，并且客户端会话也不例外3。 某些应用程序可能需要大量的会话。 为每个请求（或一组请求）来回发送此状态可以轻松克服后端减少聊天的好处。 后端的客户端数据和数据库查找之间必须保持一定的平衡。 这取决于您的应用程序的数据模型。 某些应用程序无法很好地映射到客户端会话。 其他可能完全取决于客户端数据。 这件事的最终决定权是你自己决定！ 运行基准测试，研究保留某些状态客户端的好处。 JWT太大了吗？ 这对带宽有影响吗？ 这样增加的带宽是否会取代后端减少的延迟？ 小请求可以汇总为单个大请求吗？ 这些请求是否仍然需要大型数据库查找？ 回答这些问题将帮助您确定正确的方法。
联合身份7系统允许不同（可能不相关）的各方与其他方共享身份验证和授权服务。 换句话说，用户的身份是集中的。 联合身份管理有多种解决方案：SAML8和OpenID Connect9是最常见的两种。 某些公司提供专门的产品，以集中身份验证和授权。 这些可以实现上述标准之一，也可以使用完全不同的标准。 其中一些公司为此目的使用JWT。 JWT用于集中式身份验证和授权的方法因公司而异，但是授权过程的基本流程是：
访问和刷新令牌是两种类型的令牌，在分析不同的联合身份解决方案时，您会经常看到它们。我们将简要解释它们是什么以及它们如何在身份验证和授权的上下文中提供帮助。 这两个概念通常在OAuth2规范的上下文中实现10。 OAuth2规范定义了通过将访问权限与所有权分开来提供对资源的访问所需的一系列步骤（换句话说，它允许具有不同访问级别的多个方访问同一资源）。这些步骤的几个部分由实现定义。也就是说，竞争的OAuth2实现可能无法互操作。例如，未指定令牌的实际二进制格式。它们的目的和功能是。 访问令牌是使拥有访问权限的人员可以访问受保护资源的令牌。这些令牌通常是短暂的，并且可能在其中嵌入了失效日期。它们还可以携带附加信息或与之关联（例如，访问令牌可以携带允许发出请求的IP地址）。此附加数据是实现定义的。 另一方面，刷新令牌允许客户端请求新的访问令牌。例如，在访问令牌到期后，客户端可以向授权服务器执行对新访问令牌的请求。为了满足此请求，需要刷新令牌。与访问令牌相反，刷新令牌通常是长期存在的。
访问令牌和刷新令牌之间分离的关键方面在于使访问令牌易于验证的可能性。带有签名（例如，签名的JWT）的访问令牌可以由资源服务器自行验证。为此，无需联系授权服务器。 另一方面，刷新令牌需要访问授权服务器。通过将验证与对授权服务器的查询分开，可以实现更好的延迟和更简单的访问模式。通过使访问令牌的寿命尽可能短，并将其他检查（例如客户端检查）嵌入到令牌中，可以实现令牌泄漏时的适当安全性。 刷新令牌的寿命很长，必须加以保护，以防泄漏。如果发生泄漏，则可能需要在服务器中将其列入黑名单（短暂的访问令牌会强制最终使用刷新令牌，从而在资源被列入黑名单且所有访问令牌都已过期后保护资源）。 注意：OAuth2中引入了访问令牌和刷新令牌的概念。 OAuth 1.0和1.0a使用单词令牌的方式有所不同。
尽管OAuth2没有提及其令牌的格式，但JWT可以很好地满足其要求。 签名的JWT具有良好的访问令牌，因为它们可以对所有必需的数据进行编码，以区分对资源的访问级别，可以带有到期日期，并进行签名以避免对授权服务器进行验证查询。 几个联合身份提供者以JWT格式发布访问令牌。 JWT也可以用于刷新令牌。 但是，没有太多理由将它们用于此目的。 由于刷新令牌需要访问授权服务器，因此在大多数情况下，一个简单的UUID就足够了，因为不需要令牌来承载有效负载（尽管可以对其进行签名）。
JSON Web Tokens in Detail
如第1章所述，所有JWT都由三个不同的元素构成：标头，有效负载和签名/加密数据。 前两个元素是具有特定结构的JSON对象。 第三个依赖于用于签名或加密的算法，如果是未加密的JWT，则将其省略。 JWT可以以称为JWS / JWE紧凑序列化的紧凑表示形式进行编码。 JWT使用一种对URL安全的Base64编码变体。 此编码基本上分别用“ &#43;”和“ /”字符代替“-”和“ _”字符。 填充也将被删除。 此变体称为base64url3。 请注意，本文档中对Base64编码的所有引用均指代此变体。">
<meta itemprop="datePublished" content="2020-03-29T17:06:48&#43;08:00" />
<meta itemprop="dateModified" content="2020-03-29T17:06:48&#43;08:00" />
<meta itemprop="wordCount" content="191">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Jwt Notes"/>
<meta name="twitter:description" content="JSON Web Token (JWT) JSON Web Key (JWK) jwt.io 一篇官方文档翻译，这篇文章里有一些标注为“个人补充”的内容，很有实践意义。  缓解技术依赖于对传递给后端的所有数据的正确验证。特别是，必须始终清理从客户端收到的任何数据。 如果使用cookie，则可以通过设置HttpOnly标志2来防止它们被JavaScript访问。 HttpOnly标志虽然有用，但不能保护cookie免遭CSRF攻击。
任何方法都有其优缺点，并且客户端会话也不例外3。 某些应用程序可能需要大量的会话。 为每个请求（或一组请求）来回发送此状态可以轻松克服后端减少聊天的好处。 后端的客户端数据和数据库查找之间必须保持一定的平衡。 这取决于您的应用程序的数据模型。 某些应用程序无法很好地映射到客户端会话。 其他可能完全取决于客户端数据。 这件事的最终决定权是你自己决定！ 运行基准测试，研究保留某些状态客户端的好处。 JWT太大了吗？ 这对带宽有影响吗？ 这样增加的带宽是否会取代后端减少的延迟？ 小请求可以汇总为单个大请求吗？ 这些请求是否仍然需要大型数据库查找？ 回答这些问题将帮助您确定正确的方法。
联合身份7系统允许不同（可能不相关）的各方与其他方共享身份验证和授权服务。 换句话说，用户的身份是集中的。 联合身份管理有多种解决方案：SAML8和OpenID Connect9是最常见的两种。 某些公司提供专门的产品，以集中身份验证和授权。 这些可以实现上述标准之一，也可以使用完全不同的标准。 其中一些公司为此目的使用JWT。 JWT用于集中式身份验证和授权的方法因公司而异，但是授权过程的基本流程是：
访问和刷新令牌是两种类型的令牌，在分析不同的联合身份解决方案时，您会经常看到它们。我们将简要解释它们是什么以及它们如何在身份验证和授权的上下文中提供帮助。 这两个概念通常在OAuth2规范的上下文中实现10。 OAuth2规范定义了通过将访问权限与所有权分开来提供对资源的访问所需的一系列步骤（换句话说，它允许具有不同访问级别的多个方访问同一资源）。这些步骤的几个部分由实现定义。也就是说，竞争的OAuth2实现可能无法互操作。例如，未指定令牌的实际二进制格式。它们的目的和功能是。 访问令牌是使拥有访问权限的人员可以访问受保护资源的令牌。这些令牌通常是短暂的，并且可能在其中嵌入了失效日期。它们还可以携带附加信息或与之关联（例如，访问令牌可以携带允许发出请求的IP地址）。此附加数据是实现定义的。 另一方面，刷新令牌允许客户端请求新的访问令牌。例如，在访问令牌到期后，客户端可以向授权服务器执行对新访问令牌的请求。为了满足此请求，需要刷新令牌。与访问令牌相反，刷新令牌通常是长期存在的。
访问令牌和刷新令牌之间分离的关键方面在于使访问令牌易于验证的可能性。带有签名（例如，签名的JWT）的访问令牌可以由资源服务器自行验证。为此，无需联系授权服务器。 另一方面，刷新令牌需要访问授权服务器。通过将验证与对授权服务器的查询分开，可以实现更好的延迟和更简单的访问模式。通过使访问令牌的寿命尽可能短，并将其他检查（例如客户端检查）嵌入到令牌中，可以实现令牌泄漏时的适当安全性。 刷新令牌的寿命很长，必须加以保护，以防泄漏。如果发生泄漏，则可能需要在服务器中将其列入黑名单（短暂的访问令牌会强制最终使用刷新令牌，从而在资源被列入黑名单且所有访问令牌都已过期后保护资源）。 注意：OAuth2中引入了访问令牌和刷新令牌的概念。 OAuth 1.0和1.0a使用单词令牌的方式有所不同。
尽管OAuth2没有提及其令牌的格式，但JWT可以很好地满足其要求。 签名的JWT具有良好的访问令牌，因为它们可以对所有必需的数据进行编码，以区分对资源的访问级别，可以带有到期日期，并进行签名以避免对授权服务器进行验证查询。 几个联合身份提供者以JWT格式发布访问令牌。 JWT也可以用于刷新令牌。 但是，没有太多理由将它们用于此目的。 由于刷新令牌需要访问授权服务器，因此在大多数情况下，一个简单的UUID就足够了，因为不需要令牌来承载有效负载（尽管可以对其进行签名）。
JSON Web Tokens in Detail
如第1章所述，所有JWT都由三个不同的元素构成：标头，有效负载和签名/加密数据。 前两个元素是具有特定结构的JSON对象。 第三个依赖于用于签名或加密的算法，如果是未加密的JWT，则将其省略。 JWT可以以称为JWS / JWE紧凑序列化的紧凑表示形式进行编码。 JWT使用一种对URL安全的Base64编码变体。 此编码基本上分别用“ &#43;”和“ /”字符代替“-”和“ _”字符。 填充也将被删除。 此变体称为base64url3。 请注意，本文档中对Base64编码的所有引用均指代此变体。"/>

      
    
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://potterhe.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      Potterhe&#39;s Site
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/posts/" title="Posts page">
              Posts
            </a>
          </li>
          
        </ul>
      
      




<a href="https://twitter.com/potterhe" target="_blank" class="link-transition twitter link dib z-999 pt3 pt0-l mr1" title="Twitter link" rel="noopener" aria-label="follow on Twitter——Opens in a new window">
  <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

<span class="new-window"><svg  height="8px"  style="enable-background:new 0 0 1000 1000;" version="1.1" viewBox="0 0 1000 1000" width="8px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
<path d="M598 128h298v298h-86v-152l-418 418-60-60 418-418h-152v-86zM810 810v-298h86v298c0 46-40 86-86 86h-596c-48 0-86-40-86-86v-596c0-46 38-86 86-86h298v86h-298v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>
</span></a>





<a href="https://github.com/potterhe" target="_blank" class="link-transition github link dib z-999 pt3 pt0-l mr1" title="Github link" rel="noopener" aria-label="follow on Github——Opens in a new window">
  <svg  height="32px"  style="enable-background:new 0 0 512 512;" version="1.1" viewBox="0 0 512 512" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
  <path d="M256,32C132.3,32,32,134.8,32,261.7c0,101.5,64.2,187.5,153.2,217.9c11.2,2.1,15.3-5,15.3-11.1   c0-5.5-0.2-19.9-0.3-39.1c-62.3,13.9-75.5-30.8-75.5-30.8c-10.2-26.5-24.9-33.6-24.9-33.6c-20.3-14.3,1.5-14,1.5-14   c22.5,1.6,34.3,23.7,34.3,23.7c20,35.1,52.4,25,65.2,19.1c2-14.8,7.8-25,14.2-30.7c-49.7-5.8-102-25.5-102-113.5   c0-25.1,8.7-45.6,23-61.6c-2.3-5.8-10-29.2,2.2-60.8c0,0,18.8-6.2,61.6,23.5c17.9-5.1,37-7.6,56.1-7.7c19,0.1,38.2,2.6,56.1,7.7   c42.8-29.7,61.5-23.5,61.5-23.5c12.2,31.6,4.5,55,2.2,60.8c14.3,16.1,23,36.6,23,61.6c0,88.2-52.4,107.6-102.3,113.3   c8,7.1,15.2,21.1,15.2,42.5c0,30.7-0.3,55.5-0.3,63c0,6.1,4,13.3,15.4,11C415.9,449.1,480,363.1,480,261.7   C480,134.8,379.7,32,256,32z"/>
</svg>

<span class="new-window"><svg  height="8px"  style="enable-background:new 0 0 1000 1000;" version="1.1" viewBox="0 0 1000 1000" width="8px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
<path d="M598 128h298v298h-86v-152l-418 418-60-60 418-418h-152v-86zM810 810v-298h86v298c0 46-40 86-86 86h-596c-48 0-86-40-86-86v-596c0-46 38-86 86-86h298v86h-298v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>
</span></a>







    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=https://potterhe.github.io/posts/jwt-handbook-notes/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=https://potterhe.github.io/posts/jwt-handbook-notes/&amp;text=Jwt%20Notes" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://potterhe.github.io/posts/jwt-handbook-notes/&amp;title=Jwt%20Notes" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>

      <h1 class="f1 athelas mt3 mb1">Jwt Notes</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2020-03-29T17:06:48&#43;08:00">March 29, 2020</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><ol>
<li><a href="https://tools.ietf.org/html/rfc7519">JSON Web Token (JWT)</a></li>
<li><a href="https://tools.ietf.org/html/rfc7517">JSON Web Key (JWK)</a></li>
<li><a href="https://jwt.io/">jwt.io</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1597154">一篇官方文档翻译</a>，这篇文章里有一些标注为“个人补充”的内容，很有实践意义。</li>
</ol>
<p>缓解技术依赖于对传递给后端的所有数据的正确验证。特别是，必须始终清理从客户端收到的任何数据。 如果使用cookie，则可以通过设置HttpOnly标志2来防止它们被JavaScript访问。 HttpOnly标志虽然有用，但不能保护cookie免遭CSRF攻击。</p>
<p>任何方法都有其优缺点，并且客户端会话也不例外3。 某些应用程序可能需要大量的会话。 为每个请求（或一组请求）来回发送此状态可以轻松克服后端减少聊天的好处。 后端的客户端数据和数据库查找之间必须保持一定的平衡。 这取决于您的应用程序的数据模型。 某些应用程序无法很好地映射到客户端会话。 其他可能完全取决于客户端数据。 这件事的最终决定权是你自己决定！ 运行基准测试，研究保留某些状态客户端的好处。 JWT太大了吗？ 这对带宽有影响吗？ 这样增加的带宽是否会取代后端减少的延迟？ 小请求可以汇总为单个大请求吗？ 这些请求是否仍然需要大型数据库查找？ 回答这些问题将帮助您确定正确的方法。</p>
<p>联合身份7系统允许不同（可能不相关）的各方与其他方共享身份验证和授权服务。 换句话说，用户的身份是集中的。 联合身份管理有多种解决方案：SAML8和OpenID Connect9是最常见的两种。 某些公司提供专门的产品，以集中身份验证和授权。 这些可以实现上述标准之一，也可以使用完全不同的标准。 其中一些公司为此目的使用JWT。
JWT用于集中式身份验证和授权的方法因公司而异，但是授权过程的基本流程是：</p>
<p>访问和刷新令牌是两种类型的令牌，在分析不同的联合身份解决方案时，您会经常看到它们。我们将简要解释它们是什么以及它们如何在身份验证和授权的上下文中提供帮助。
这两个概念通常在OAuth2规范的上下文中实现10。 OAuth2规范定义了通过将访问权限与所有权分开来提供对资源的访问所需的一系列步骤（换句话说，它允许具有不同访问级别的多个方访问同一资源）。这些步骤的几个部分由实现定义。也就是说，竞争的OAuth2实现可能无法互操作。例如，未指定令牌的实际二进制格式。它们的目的和功能是。
访问令牌是使拥有访问权限的人员可以访问受保护资源的令牌。这些令牌通常是短暂的，并且可能在其中嵌入了失效日期。它们还可以携带附加信息或与之关联（例如，访问令牌可以携带允许发出请求的IP地址）。此附加数据是实现定义的。
另一方面，刷新令牌允许客户端请求新的访问令牌。例如，在访问令牌到期后，客户端可以向授权服务器执行对新访问令牌的请求。为了满足此请求，需要刷新令牌。与访问令牌相反，刷新令牌通常是长期存在的。</p>
<p>访问令牌和刷新令牌之间分离的关键方面在于使访问令牌易于验证的可能性。带有签名（例如，签名的JWT）的访问令牌可以由资源服务器自行验证。为此，无需联系授权服务器。
另一方面，刷新令牌需要访问授权服务器。通过将验证与对授权服务器的查询分开，可以实现更好的延迟和更简单的访问模式。通过使访问令牌的寿命尽可能短，并将其他检查（例如客户端检查）嵌入到令牌中，可以实现令牌泄漏时的适当安全性。
刷新令牌的寿命很长，必须加以保护，以防泄漏。如果发生泄漏，则可能需要在服务器中将其列入黑名单（短暂的访问令牌会强制最终使用刷新令牌，从而在资源被列入黑名单且所有访问令牌都已过期后保护资源）。
注意：OAuth2中引入了访问令牌和刷新令牌的概念。 OAuth 1.0和1.0a使用单词令牌的方式有所不同。</p>
<p>尽管OAuth2没有提及其令牌的格式，但JWT可以很好地满足其要求。 签名的JWT具有良好的访问令牌，因为它们可以对所有必需的数据进行编码，以区分对资源的访问级别，可以带有到期日期，并进行签名以避免对授权服务器进行验证查询。 几个联合身份提供者以JWT格式发布访问令牌。
JWT也可以用于刷新令牌。 但是，没有太多理由将它们用于此目的。 由于刷新令牌需要访问授权服务器，因此在大多数情况下，一个简单的UUID就足够了，因为不需要令牌来承载有效负载（尽管可以对其进行签名）。</p>
<p>JSON Web Tokens in Detail</p>
<p>如第1章所述，所有JWT都由三个不同的元素构成：标头，有效负载和签名/加密数据。 前两个元素是具有特定结构的JSON对象。 第三个依赖于用于签名或加密的算法，如果是未加密的JWT，则将其省略。 JWT可以以称为JWS / JWE紧凑序列化的紧凑表示形式进行编码。
JWT使用一种对URL安全的Base64编码变体。 此编码基本上分别用“ +”和“ /”字符代替“-”和“ _”字符。 填充也将被删除。 此变体称为base64url3。 请注意，本文档中对Base64编码的所有引用均指代此变体。</p>
<p>每个JWT都带有标有其自身声明的标头（也称为JOSE标头）。 这些声明建立了所使用的算法，无论是对JWT进行签名还是加密，以及通常如何解析JWT的其余部分。</p>
<p>338/5000
根据所讨论的JWT的类型，标头中可能必须包含更多字段。 例如，加密的JWT携带有关用于密钥加密和内容加密的加密算法的信息。 对于未加密的JWT，这些字段不存在。
未加密的JWT标头的唯一强制性声明是alg声明</p>
<p>alg：用于对该JWT进行签名和/或解密的主要算法。
对于未加密的JWT，此声明必须设置为none</p>
<p>可选的标头声明包括typ和cty声明：
•typ：JWT本身的媒体类型5。 此参数仅用于在JWT与带有JOSE标头的其他对象混合使用时提供帮助。 实际上，这种情况很少发生。 如果存在，则此声明应设置为值JWT。
•cty：内容类型。 大多数JWT携带特定的声明以及任意数据作为其有效载荷的一部分。 在这种情况下，不得设置内容类型声明。 对于有效载荷本身是JWT（嵌套JWT）的实例，此声明必须存在并带有值JWT。 这告诉实现，需要进一步处理嵌套的JWT。 嵌套的JWT很少，因此在标题中很少出现cty声明</p>
<p>有效负载是通常添加所有有趣的用户数据的元素。 此外，还可能存在本规范中定义的某些权利要求。 就像标题一样，有效负载是一个JSON对象。 尽管特定的权利要求具有明确的含义，但没有任何权利要求是强制性的。 JWT规范指定应忽略实现无法理解的声明。 具有所附特定含义的权利要求被称为注册权利要求。</p>
<p>iss：来自“发行者”一词。区分大小写的字符串或URI，用于唯一标识发出JWT的参与方。其解释是针对特定应用程序的（没有中央机构来管理发行者）。
•sub：来自主题一词。区分大小写的字符串或URI，用于唯一标识此JWT携带其信息的参与方。换句话说，此JWT中包含的声明是关于该方的声明。 JWT规范规定，此声明在发行方的上下文中必须是唯一的，或者在不可能的情况下必须是全局唯一的。处理此声明是特定于应用程序的。
•aud：来自“听众”一词。单个区分大小写的字符串或URI或唯一标识此JWT预期收件人的此类值的数组。换句话说，当存在此声明时，读取此JWT中的数据的一方必须在aud声明中发现自己或忽略JWT中包含的数据。与iss和从属权利要求的情况一样，该权利要求是专用的。</p>
<p>exp：从单词expiration（时间）开始。代表特定日期和时间的数字，格式为POSIX6定义的“自纪元后的秒数”。此声明设置了此JWT被视为无效的确切时间。一些实现可能允许时钟之间存在一定的偏斜（通过考虑此JWT在到期日期后的几分钟内有效）。
•nbf：从不早于（时间）开始。与exp声明相反。代表特定日期和时间的数字，格式为POSIX7定义的“自纪元以来的秒数”。该声明确定了该JWT生效的确切时间。当前时间和日期必须等于或晚于该日期和时间。一些实现可能允许一定的偏斜。
•iat：从（时间）发布。一个数字，表示发出此JWT的特定日期和时间（格式与exp和nbf相同）。
•jti：来自JWT ID。表示此JWT的唯一标识符的字符串。此声明可用于区分具有其他相似内容的JWT（例如，防止重放）。取决于实现以确保唯一性。</p>
<p>所有不属于已注册索赔部分的索赔均为私人或公共索赔。
•私人索赔：由JWT的用户（消费者和生产者）定义的索赔。换句话说，这些是用于特定情况的临时声明。因此，必须注意防止碰撞。
•公开声明：是已在IANA JSON Web令牌声明注册中心8（用户可以在其中注册其声明并因此避免冲突的注册表）中注册的声明，或使用抗冲突名称命名的声明（例如，在名称空间前添加名称空间）名称）。
实际上，大多数索赔是注册索赔或私人索赔。通常，大多数JWT的发布都是出于特定目的，并且明确了一组潜在的用户。这使得选择抗碰撞名称的问题变得简单。
就像JSON解析规则中一样，重复声明（重复的JSON密钥）仅通过将最后一次出现保留为有效来处理。 JWT规范还使实现有可能将具有重复声明的JWT视为无效。实际上，如果您不确定将处理JWT的实现，请注意避免重复声明。</p>
<p>像上面显示的那样，无担保的JWT可能适合客户端使用。 例如，如果会话ID是一个难以猜测的数字，而其余数据仅由客户端用于构造视图，则使用签名是多余的。 单页Web应用程序可以使用此数据为用户构造一个具有“漂亮”名称的视图，而无需在后端被重定向到他最后访问的页面时点击后端。 即使恶意用户修改此数据，他或她也不会获得任何收益。
请注意紧凑表示形式中的尾随点（。）。 由于没有签名，因此它只是一个空字符串。 但是，该点仍被添加。</p>
<p>所有签名算法都完成相同的事情：它们提供一种方法来建立JWT中包含的数据的真实性。他们的做法各不相同。
密钥哈希消息验证码（HMAC）是一种使用加密哈希函数将特定有效载荷与机密结合在一起的算法。结果是只有在生成方和验证方都知道机密的情况下，才可以用来验证消息的代码。换句话说，HMAC允许通过共享机密验证消息。o
用于JWT的最常见签名算法HS256中使用的加密哈希函数是SHA-256。 SHA-256在第7章中进行了详细说明。加密散列函数采用任意长度的消息并产生固定长度的输出。相同的消息将始终产生相同的输出。哈希函数的加密部分确保从数学上无法从函数的输出中恢复原始消息。这样，加密哈希函数是一种单向函数，可用于标识消息，而无需实际共享消息。消息中的微小变化（例如单个字节）将产生完全不同的输出。</p>
<p>JWS允许强制标头进行更多声明的特殊用例。 例如，对于公共密钥签名算法，可以将URL嵌入到公共密钥中作为声明。 以下是可用于JWS令牌的已注册标头声明的列表。 所有这些声明是对不安全JWT可用的声明的补充，并且根据要使用签名的JWT的方式是可选的。</p>
<p>•jku：JSON Web密钥（JWK）设置URL。指向一组用于对此JWT签名的JSON编码公共密钥的URI。必须使用传输安全性（例如HTTP的TLS）来检索密钥。密钥的格式为JWK集（请参见第6章）。
•jwk：JSON Web密钥。用于以JSON Web密钥格式对此JWT进行签名的密钥（请参见第6章）。
•kid：密钥ID。用户定义的字符串，表示用于签署此JWT的单个密钥。此声明用于向接收者发出密钥签名更改的信号（使用多个密钥时）。
•x5u：X.509 URL。指向一组以PEM格式编码的X.509（证书格式标准）公共证书的URI。集合中的第一个证书必须是用于对此JWT签名的证书。后续证书均对前一个证书进行签名，从而完成证书链。 X.509在RFC 52807中定义。传输证书需要传输安全性。
•x5c：X.509证书链。用于签署此JWS的X.509证书的JSON数组。每个证书必须是其DER PKIX表示形式的Base64编码值。数组中的第一个证书必须是用于对此JWT签名的证书，然后是证书链中的其余证书。
•x5t：X.509证书SHA-1指纹。用于对此JWT签名的X.509 DER编码证书的SHA-1指纹。
•x5t＃S256：与x5t相同，但是使用SHA-256而不是SHA-1。
•typ：与未加密的JWT的typ值相同，附加值“ JOSE”和“ JOSE + JSON”分别用于表示紧凑序列化和JSON序列化。仅在将类似的JOSE标头运载对象与此混合的情况下使用
JWT在单个容器中。
•crit：从暴击。字符串数组，带有在同一标头中存在的声明名称，该字符串用作实现定义的扩展，必须由此JWT的解析器处理。它必须包含声明的名称或不存在（空数组不是有效值）。</p>
<p>在JWS JSON序列化表格中，已签名的JWT表示为JSON格式的可打印文本（即，从浏览器中调用JSON.stringify会得到的结果）。最高的JSON对象
需要以下键值对：
•有效负载：实际JWT有效负载对象的Base64编码的字符串。
•签名：带有签名的JSON对象数组。这些对象已定义
下面。
反过来，签名数组中的每个JSON对象必须包含以下键/值对：
•protected：JWS标头的Base64编码的字符串。此标头中包含的声明受签名保护。仅当没有不受保护的标头时才需要此标头。如果存在不受保护的标头，则此标头可能存在也可能不存在。
•标头：包含标头声明的JSON对象。此标头不受签名保护。如果不存在受保护的标头，则此元素是必需的。如果存在受保护的标头，则此元素是可选的。
•签名：JWS签名的Base64编码字符串。
与紧凑的序列化形式（仅存在受保护的标头）相比，JSON序列化接受两种标头：protected和unprotected。受保护的标头由签名验证。未受保护的标头未通过其验证。由实施者或用户来选择将哪个声明放入其中。这些标头中至少必须存在一个。两者也可以同时存在。
当同时存在受保护和不受保护的标头时，实际的JOSE标头是通过两个标头中元素的并集构建的。没有重复的要求。</p>
<p>从技术上讲，这是有可能的，但这没有任何意义。 共享私钥等效于共享密钥。 因此，共享私钥在本质上将方案变成了共享秘密方案，而没有公钥的实际好处（请记住，公钥可以从私钥派生）。
因此，有时会嵌套加密的JWT：加密的JWT充当签名JWT的容器。 这样您就可以同时获得两者的好处。</p>
<p>紧凑表示的五个元素依次为：
1.受保护的标头：类似于JWS标头的标头。
2.加密密钥：用于加密密文和其他加密密钥的对称密钥
数据。 该密钥是由用户指定的实际加密密钥派生的，因此被其加密。
3.初始化向量：某些加密算法需要其他（通常是随机的）数据。
4.加密的数据（密文）：正在加密的实际数据。
5.身份验证标签：算法产生的其他数据，可用于
验证密文的内容以防篡改。</p>
<p>为了完成JWT，JWS和JWE的介绍，我们现在进入JSON Web密钥（JWK）规范。 本规范处理用于签名和加密的密钥的不同表示形式。 尽管已经为所有键建立了表示，但是JWK规范旨在为JSON Web算法（JWA）规范中支持的所有键提供统一的表示。 统一的密钥表示格式允许轻松共享，并使密钥独立于其他密钥交换格式的复杂性。
JWS和JWE确实支持另一种类型的密钥格式：X.509证书。 这些很常见，并且可以承载比JWK更多的信息。 X.509证书可以嵌入JWK中，并可以从它们中构造JWK。
密钥在不同的标题声明中指定。 文字JWK置于jwk声明之下。 另一方面，jku声明可以指向存储在URL下的一组密钥。 这两个声明均为JWK格式。</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://potterhe.github.io/" >
    &copy;  Potterhe's Site 2020 
  </a>
    <div>




<a href="https://twitter.com/potterhe" target="_blank" class="link-transition twitter link dib z-999 pt3 pt0-l mr1" title="Twitter link" rel="noopener" aria-label="follow on Twitter——Opens in a new window">
  <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

<span class="new-window"><svg  height="8px"  style="enable-background:new 0 0 1000 1000;" version="1.1" viewBox="0 0 1000 1000" width="8px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
<path d="M598 128h298v298h-86v-152l-418 418-60-60 418-418h-152v-86zM810 810v-298h86v298c0 46-40 86-86 86h-596c-48 0-86-40-86-86v-596c0-46 38-86 86-86h298v86h-298v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>
</span></a>





<a href="https://github.com/potterhe" target="_blank" class="link-transition github link dib z-999 pt3 pt0-l mr1" title="Github link" rel="noopener" aria-label="follow on Github——Opens in a new window">
  <svg  height="32px"  style="enable-background:new 0 0 512 512;" version="1.1" viewBox="0 0 512 512" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
  <path d="M256,32C132.3,32,32,134.8,32,261.7c0,101.5,64.2,187.5,153.2,217.9c11.2,2.1,15.3-5,15.3-11.1   c0-5.5-0.2-19.9-0.3-39.1c-62.3,13.9-75.5-30.8-75.5-30.8c-10.2-26.5-24.9-33.6-24.9-33.6c-20.3-14.3,1.5-14,1.5-14   c22.5,1.6,34.3,23.7,34.3,23.7c20,35.1,52.4,25,65.2,19.1c2-14.8,7.8-25,14.2-30.7c-49.7-5.8-102-25.5-102-113.5   c0-25.1,8.7-45.6,23-61.6c-2.3-5.8-10-29.2,2.2-60.8c0,0,18.8-6.2,61.6,23.5c17.9-5.1,37-7.6,56.1-7.7c19,0.1,38.2,2.6,56.1,7.7   c42.8-29.7,61.5-23.5,61.5-23.5c12.2,31.6,4.5,55,2.2,60.8c14.3,16.1,23,36.6,23,61.6c0,88.2-52.4,107.6-102.3,113.3   c8,7.1,15.2,21.1,15.2,42.5c0,30.7-0.3,55.5-0.3,63c0,6.1,4,13.3,15.4,11C415.9,449.1,480,363.1,480,261.7   C480,134.8,379.7,32,256,32z"/>
</svg>

<span class="new-window"><svg  height="8px"  style="enable-background:new 0 0 1000 1000;" version="1.1" viewBox="0 0 1000 1000" width="8px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
<path d="M598 128h298v298h-86v-152l-418 418-60-60 418-418h-152v-86zM810 810v-298h86v298c0 46-40 86-86 86h-596c-48 0-86-40-86-86v-596c0-46 38-86 86-86h298v86h-298v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>
</span></a>






</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
